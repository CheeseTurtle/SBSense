classdef Analyzer < handle & matlab.mixin.SetGetExactNames
properties(GetAccess=private,SetAccess=private,Transient)
    APQueue parallel.pool.DataQueue;
    ResQueue parallel.pool.DataQueue;
    finishedQueue parallel.pool.PollableDataQueue;
end
properties(SetAccess=private,GetAccess=public,Transient)
    HCQueue parallel.pool.DataQueue;
    AnalysisParams; %sbsense.AnalysisParameters;
    lfit sbsense.LorentzFitter;
    SignalFcn function_handle;
    
    AnalysisFutures (1,:) parallel.Future;
end

properties(GetAccess=public,SetAccess=protected,Transient,NonCopyable)
    ConstObj parallel.pool.Constant;
end

properties(GetAccess=public,SetAccess=private)
    fph;
end

properties(GetAccess=public,SetAccess=private)
    PSBWidth (1,1) uint16;
    ChHorzIdxs (1,:) uint16;
end

properties(SetAccess=public,SetObservable,AbortSet)
    PSBL (1,1) uint16;
    PSBR (1,1) uint16;
end

methods
    function obj = Analyzer(resQueue, signalFcn, paramsObjHandle)
        obj.ResQueue = resQueue;
        obj.SignalFcn = signalFcn;
        obj.lfit = sbsense.LorentzFitter(); % TODO: Args
        obj.AnalysisParams = paramsObjHandle;

        obj.APQueue = parallel.pool.DataQueue();
        afterEach(obj.APQueue, @obj.APFcn);
        obj.HCQueue = parallel.pool.DataQueue();
        afterEach(obj.HCQueue, @obj.HCFcn);
        obj.finishedQueue = parallel.pool.PollableDataQueue();

        addlistener(obj, {'PSBL', 'PSBR'}, 'PostSet', @obj.postset_psb);
    end

    % (BGimg), (NumChs)
    function initialize(obj, resQueue, varargin) % varargin: BGimg, numChannels, analysisScale
        obj.ResQueue = resQueue;
        initialize(obj.AnalysisParams, varargin{:});
    end

    % (analysisScale)
    function prepare(obj,resQueue,fph,varargin)
        obj.ResQueue = resQueue;
        obj.fph = fph;
        if isa(obj.HCQueue, 'parallel.pool.DataQueue') && ...
            (~isvalid(obj.HCQueue) || obj.HCQueue.QueueLength) % TODO: Name of prop??
            delete(obj.HCQueue);
            obj.HCQueue = parallel.pool.DataQueue();
            afterEach(obj.HCQueue, @obj.HCFcn);
        end
        if isa(obj.APQueue, 'parallel.pool.DataQueue') && ...
            (~isvalid(obj.APQueue) || obj.APQueue.QueueLength) % TODO: Name of prop??
            delete(obj.APQueue);
            obj.APQueue = parallel.pool.DataQueue();
            afterEach(obj.APQueue, @obj.APFcn);
        end
        if isa(obj.finishedQueue, 'parallel.pool.DataQueue') && ...
            (~isvalid(obj.finishedQueue) || obj.finishedQueue.QueueLength) % TODO: Name of prop??
            delete(obj.finishedQueue);
            obj.finishedQueue = parallel.pool.PollableDataQueue();
        end
        
        prepare(obj.AnalysisParams, varargin{:});

        obj.ConstObj = parallel.pool.Constant(obj.AnalysisParams);
    end
end

methods(Access=protected)
    function HCFcn(obj, HCdata)
        persistent prevHCimg prevHCtimeRange;
        % HCdata: {datapointIndex, HCtimeRange, frames}
        [datapointIndex, timeRange, frames] = HCdata{:};
        HC = im2double(sbsense.improc.makeHalfComposite(0.5*obj.fph,frames));
        if(datapointIndex && ~isempty(prevHCimg))
            datapointTimePos = ...
                prevHCtimeRange(1) + ...
                0.5*(timeRange(2) - prevHCtimeRange(1));
            send(obj.finishedQueue, datapointIndex);
            send(obj.APQueue, ...
                {false, datapointIndex, datapointTimePos, prevHCimg, HC});
            % APdata: {isReanalysis, index, timePos, HC1, HC2}
        end
        prevHCtimeRange = timeRange;
        prevHCimg = HC;
    end

    function APFcn(obj, APdata)
        fprintf('Received APdata: %s', formattedDisplayText(APdata));
        if isequal(APdata, true)
            send(obj.ResQueue, true);
            return;
        end
        fut = parfeval(backgroundPool, @analyzeHCs, 1, obj.lfit, ...
            obj.AnalysisParams, [obj.PSBL obj.PSBR], ...
            APdata{:}); % APdata: {isReanalysis, index, timePos, HC1, HC2}
        if isempty(obj.AnalysisFutures)
            obj.AnalysisFutures = fut;
        else
            obj.AnalysisFutures(end+1) = fut;
        end
        afterEach(fut, @obj.clearFuture, 0, 'PassFuture', true);
    end

    function postset_psb(obj, ~, ~)
        obj.PSBWidth = obj.PSBR - obj.PSBL - 1;
        obj.ChHorzIdxs = obj.PSBL:obj.PSBR;
    end
end

methods(Access=private)
    function clearFuture(obj, fut)
        try
            % if ~obj.finishedQueue.QueueLength
            %     fprintf('[clearFuture] finishedQueue is unexpectedly empty!\n');
            % else
            %     poll(obj.FinishedQueue);
            % end
            
            if ~isempty(fut.Error)
                if (fut.Error.identifier ~= "parallel:fevalqueue:ExecutionCancelled")
                    fprintf('[APFcn>clearFuture] fut.Error "%s": %s\n', ...
                        fut.Error.identifier, getReport(fut.Error));
                        %celldisp(fut.Error.stack);
                end
                return;
            elseif isempty(fut.OutputArguments)
                fprintf('[APFcn>clearFuture] OutputArguments is unexpectedly empty!\n');
                return;
            elseif ~isempty(fut.OutputArguments{1})
                if isstruct(fut.OutputArguments{1})
                    send(obj.ResQueue, fut.OutputArguments{1});
                elseif isa(fut.OutputArguments{1}, 'MException')
                    fprintf('[APFcn>clearFuture] res=error "%s": %s\n', ...
                        fut.OutputArguments{1}.identifier, ...
                        getReport(fut.OutputArguments{1}));
                end
            end
            % obj.AnalysisFutures(obj.AnalysisFutures==fut) = [];
        catch ME
            fprintf('[clearFuture] Error "%s": %s\n', ...
                ME.identifier, getReport(ME));
            % display(fut.Error);
            % obj.AnalysisFutures(obj.AnalysisFutures==fut) = [];
            % rethrow(ME);
        end
        obj.AnalysisFutures(obj.AnalysisFutures==fut) = [];
    end
end

end